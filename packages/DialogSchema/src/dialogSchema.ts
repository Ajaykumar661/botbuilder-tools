#!/usr/bin/env node
/**
 * Copyright(c) Microsoft Corporation.All rights reserved.
 * Licensed under the MIT License.
 */
// tslint:disable:no-console
// tslint:disable:no-object-literal-type-assertion
import * as chalk from 'chalk';
import * as dt from 'dialogtracker';
import * as fs from 'fs-extra';
import glob from 'globby';
import * as os from 'os';
import * as ppath from 'path';
import * as xp from 'xml2js';
import * as Validator from 'ajv';

let allof: any = require('json-schema-merge-allof');
let clone = require('clone');
let parser: any = require('json-schema-ref-parser');

const jsonOptions = { spaces: 4, EOL: os.EOL };

let failed = false;
let missingTypes = new Set();

// NOTE: This relies on an internal copy of dialogSchema.schema which is generated by deleting the old file 
// and then running this which will pull in the standard meta-schema from the web.

/** Merge together .schema and .lg files to make a custom schema.
 * @param patterns Glob patterns for the .schema files to combine.
 * @param output The output file to create.  app.schema by default.
 * @param flat True to produce flat .lg output, false for hierarchical.  If undefined will keep the format of the input files.
 */
export async function mergeSchemas(patterns: string[], output?: string, flat?: boolean): Promise<boolean> {
    failed = false;
    missingTypes = new Set();
    let schemaPaths = [];
    for await (const path of expandPackages(await glob(patterns))) {
        schemaPaths.push(path);
    }
    if (schemaPaths.length == 0) {
        return false;
    } else {
        let progress = (msg: string) => console.log(chalk.default.grey(msg));
        let warning = (msg: string) => console.log(chalk.default.yellowBright(msg));
        let result = (msg: string) => console.log(msg);
        let definitions: any = {};
        let validator = new Validator();
        let metaSchema = await getMetaSchema();
        validator.addSchema(metaSchema, 'cogSchema');
        for (let schemaPath of schemaPaths) {
            progress(`Parsing ${schemaPath}`);
            try {
                let schema = allof(await parser.dereference(schemaPath));
                if (schema.$id) {
                    warning(`  Skipping because of top-level $id:${schema.$id}.`);
                } else {
                    delete schema.$schema;
                    if (!validator.validate('cogSchema', schema)) {
                        for (let error of <Validator.ErrorObject[]>validator.errors) {
                            schemaError(error);
                        }
                    }
                    let filename = <string>schemaPath.split(/[\\\/]/).pop();
                    let type = filename.substr(0, filename.lastIndexOf("."));
                    if (!schema.type && !isUnionType(schema)) {
                        schema.type = "object";
                    }
                    definitions[type] = schema;
                }
            } catch (e) {
                thrownError(e);
            }
        }
        fixDefinitionReferences(definitions);
        processRoles(definitions, metaSchema);
        addTypeTitles(definitions);
        expandTypes(definitions);
        addStandardProperties(definitions, metaSchema);
        sortUnions(definitions);
        if (!output) {
            output = "app.schema";
        }
        let finalDefinitions: any = {};
        for (let key of Object.keys(definitions).sort()) {
            finalDefinitions[key] = definitions[key];
        }
        let finalSchema = {
            $schema: metaSchema.$id,
            $id: ppath.basename(output),
            type: "object",
            title: "Component types",
            description: "These are all of the types that can be created by the loader.",
            oneOf: Object.keys(definitions)
                .filter((schemaName) => !isUnionType(definitions[schemaName]))
                .sort()
                .map((schemaName) => {
                    return {
                        title: schemaName,
                        description: definitions[schemaName].description || "",
                        $ref: "#/definitions/" + schemaName
                    };
                }),
            definitions: finalDefinitions
        };

        if (!failed) {
            result(`Writing ${output}`);
            await fs.writeJSON(output, finalSchema, jsonOptions);
            console.log("");
            progress("Generating .lg files");
            let schema = new dt.SchemaTracker();
            await schema.getValidator(output);
            let lg = new dt.LGTracker(schema);
            for (let schemaPath of schemaPaths) {
                await lg.addLGFiles([ppath.join(ppath.dirname(schemaPath), ppath.basename(schemaPath, ".schema") + "*.lg")], progress);
            }
            for (let multiple of lg.multiplyDefined()) {
                let template0 = multiple[0];
                let desc = `${template0.name} has multiple definitions: `;
                for (let template of multiple) {
                    desc += ` ${template.file}:${template.line}`;
                }
                warning(desc);
            }
            await lg.writeFiles(ppath.join(ppath.dirname(output), ppath.basename(output, ".schema") + ".lg"), flat, result);
        } else {
            console.log(chalk.default.redBright("Could not merge schemas"));
        }
    }
    return true;
}

/** Expand package.json, package.config or .csproj to look for .schema below referenced packages. */
async function* expandPackages(paths: string[]): AsyncIterable<string> {
    for (let path of paths) {
        let references: string[] = [];
        if (path.endsWith(".schema")) {
            yield path;
        } else if (path.endsWith(".csproj")) {
            let json = await xmlToJSON(path);
            let packages = await findParentDirectory(ppath.dirname(path), "packages");
            if (packages) {
                walkJSON(json, (elt) => {
                    let done = false;
                    if (elt.PackageReference) {
                        let pkg = elt.PackageReference[0].$;
                        let pkgName = `${pkg.Include}.${pkg.Version}`;
                        references.push(ppath.join(packages, pkgName) + "/**/*.schema");
                        done = true;
                    }
                    return done;
                });
            }
        } else if (path.endsWith("packages.config")) {
            let json = await xmlToJSON(path);
            let packages = await findParentDirectory(ppath.dirname(path), "packages");
            if (packages) {
                let references: string[] = [];
                walkJSON(json, (elt) => {
                    let done = false;
                    if (elt.package) {
                        for (let info of elt.package) {
                            let id = `${info.$.id}.${info.$.version}`;
                            references.push(ppath.join(packages, `${id}/**/*.schema`));
                        }
                        done = true;
                    }
                    return done;
                });
            }
        } else if (path.endsWith("package.json")) {
            let json = await fs.readJSON(path);
            for (let pkg in json.dependencies) {
                references.push(ppath.join(ppath.dirname(path), `node_modules/${pkg}/**/*.schema`));
            }
        }
        for (let ref of references) {
            for (let expandedRef in await glob(ref)) {
                yield expandedRef;
            }
        }
    }
    return [];
}

async function xmlToJSON(path: string): Promise<string> {
    let xml = (await fs.readFile(path)).toString();
    return new Promise((resolve, reject) =>
        xp.parseString(xml, (err: Error, result: any) => {
            if (err) {
                reject(err);
            } else {
                resolve(result);
            }
        }));
}

async function findParentDirectory(path: string, dir: string): Promise<string> {
    path = ppath.resolve(path);
    let result = "";
    if (path) {
        result = ppath.join(path, dir);
        if (!await fs.pathExists(result)) {
            result = await findParentDirectory(ppath.dirname(path), dir);
        }
    }
    return result;
}

async function getMetaSchema(): Promise<any> {
    let metaSchema: any;
    let schemaName = ppath.join(__dirname, "../src/dialogSchema.schema");
    if (!await fs.pathExists(schemaName)) {
        console.log("Generating dialogSchema.schema");
        let baseName = ppath.join(__dirname, "../src/baseCogSchema.schema");
        let schema = await fs.readJSON(baseName);
        let metaSchemaName = schema.$schema;
        let metaSchemaDef = await getURL(metaSchemaName);
        metaSchema = JSON.parse(metaSchemaDef);
        for (let prop in schema) {
            let propDef = schema[prop];
            if (typeof propDef === "string") {
                metaSchema[prop] = propDef;
            } else {
                for (let subProp in propDef) {
                    metaSchema[prop][subProp] = propDef[subProp];
                }
            }
        }
        metaSchema.$comment = "This file is generated by running the cogSchema node tool when there is not a dialogSchema.schema file.";
        await fs.writeJSON(schemaName, metaSchema, jsonOptions);
    } else {
        metaSchema = await fs.readJSON(schemaName);
    }
    return metaSchema;
}

function processRoles(definitions: any, metaSchema: any): void {
    for (let type in definitions) {
        walkJSON(definitions[type], (val: any, _obj, key) => {
            if (val.$role) {
                if (typeof val.$role === "string") {
                    processRole(val.$role, val, type, definitions, metaSchema, key);
                } else {
                    for (let role of val.$role) {
                        processRole(role, val, type, definitions, metaSchema, key);
                    }
                }
            }
            return false;
        });
    }
}

function processRole(role: string, elt: any, type: string, definitions: any, metaSchema: any, key?: string): void {
    const prefix = "unionType(";
    if (role === "lg") {
        if (!key) {
            errorMsg(type, "lg $role must be in a property defnition.");
        }
        if (elt.type) {
            errorMsg(type, `$role:lg should not have a type.`);
        }
        for (let prop in metaSchema.definitions.lg) {
            elt[prop] = metaSchema.definitions.lg[prop];
        }
    } else if (role === "unionType") {
        if (key) {
            errorMsg(type, "unionType $role can only be defined at the top of the schema definition.");
        }
    } else if (role.startsWith(prefix) && role.endsWith(")")) {
        let unionType = role.substring(prefix.length, role.length - 1);
        if (!definitions[unionType]) {
            errorMsg(type, `union type ${unionType} is not defined.`);
        } else if (!isUnionType(definitions[unionType])) {
            errorMsg(unionType, `is missing $role of unionType.`);
        } else {
            let definition = definitions[type];
            let unionDefinition = definitions[unionType];
            if (!unionDefinition.oneOf) {
                unionDefinition.oneOf = [];
            }
            unionDefinition.oneOf.push({
                title: type,
                description: definition.description || "",
                $ref: `#/definitions/${type}`
            });
        }
    }
}

function addTypeTitles(definitions: any): void {
    walkJSON(definitions, (val) => {
        if (val.oneOf) {
            walkJSON(val.oneOf, (def) => {
                if (def.type) {
                    // NOTE: This overrides any existing title but prevents namespace collision
                    def.title = def.type;
                }
                return false;
            });
        }
        return false;
    });
}

function fixDefinitionReferences(definitions: any): void {
    for (let type in definitions) {
        walkJSON(definitions[type], (val: any) => {
            if (val.$ref) {
                let ref: string = val.$ref;
                if (ref.startsWith("#/definitions/")) {
                    val.$ref = "#/definitions/" + type + "/definitions" + ref.substr(ref.indexOf('/'));
                }
            }
            return false;
        });
    }
}

function expandTypes(definitions: any): void {
    walkJSON(definitions, (val) => {
        if (val.$type) {
            if (definitions.hasOwnProperty(val.$type)) {
                val.$ref = "#/definitions/" + val.$type;
            } else {
                missing(val.$type);
            }
        }
        return false;
    });
}

function addStandardProperties(definitions: any, cogSchema: any): void {
    for (let type in definitions) {
        let definition = definitions[type];
        if (!isUnionType(definition)) {
            // Reorder properties to put $ first.
            let props: any = {
                $type: clone(cogSchema.definitions.type),
                $copy: cogSchema.definitions.copy,
                $id: cogSchema.definitions.id
            };
            props.$type.const = type;
            if (definition.properties) {
                for (let prop in definition.properties) {
                    props[prop] = definition.properties[prop];
                }
            }
            definition.properties = props;
            definition.additionalProperties = false;
            definition.patternProperties = { "^\\$": { type: "string" } };
            if (definition.required) {
                let required = definition.required;
                definition.required = ["$type"];
                definition.anyOf = [
                    {
                        title: "Reference",
                        required: ["$copy"]
                    },
                    {
                        title: "Type",
                        required: required
                    }
                ];
            } else {
                definition.required = ["$type"];
            }
        }
    }
}

function sortUnions(definitions: any): void {
    for (let key in definitions) {
        let definition = definitions[key];
        if (isUnionType(definition) && definition.oneOf) {
            definition.oneOf = definition.oneOf.sort((a: any, b: any) => a.title.localeCompare(b.title));
        }
    }
}

function walkJSON(elt: any, fun: (val: any, obj?: any, key?: string) => boolean, obj?: any, key?: any): boolean {
    let done = fun(elt, obj, key);
    if (!done) {
        if (Array.isArray(elt)) {
            for (let val of elt) {
                done = walkJSON(val, fun);
                if (done) break;
            }
        }
        else if (typeof elt === 'object') {
            for (let val in elt) {
                done = walkJSON(elt[val], fun, elt, val);
                if (done) break;
            }
        }
    }
    return done;
}

async function getURL(url: string): Promise<any> {
    return new Promise((resolve, reject) => {
        const http = require('http'),
            https = require('https');

        let client = http;

        if (url.toString().indexOf("https") === 0) {
            client = https;
        }

        client.get(url, (resp: any) => {
            let data = '';

            // A chunk of data has been recieved.
            resp.on('data', (chunk: any) => {
                data += chunk;
            });

            // The whole response has been received. 
            resp.on('end', () => {
                resolve(data);
            });

        }).on("error", (err: any) => {
            reject(err);
        });
    });
};

function isUnionType(schema: any): boolean {
    return schema.$role === "unionType";
}

function missing(type: string): void {
    if (!missingTypes.has(type)) {
        console.log(chalk.default.redBright("Missing " + type + " schema file from merge."));
        missingTypes.add(type);
        failed = true;
    }
}

function schemaError(error: Validator.ErrorObject): void {
    console.log(chalk.default.redBright(`  ${error.dataPath} ${error.message}`));
    failed = true;
}

function thrownError(error: Error): void {
    console.log(chalk.default.redBright("  " + error.message));
    failed = true;
}

function errorMsg(type: string, message: string): void {
    console.log(chalk.default.redBright(`${type}: ${message}`));
    failed = true;
}


